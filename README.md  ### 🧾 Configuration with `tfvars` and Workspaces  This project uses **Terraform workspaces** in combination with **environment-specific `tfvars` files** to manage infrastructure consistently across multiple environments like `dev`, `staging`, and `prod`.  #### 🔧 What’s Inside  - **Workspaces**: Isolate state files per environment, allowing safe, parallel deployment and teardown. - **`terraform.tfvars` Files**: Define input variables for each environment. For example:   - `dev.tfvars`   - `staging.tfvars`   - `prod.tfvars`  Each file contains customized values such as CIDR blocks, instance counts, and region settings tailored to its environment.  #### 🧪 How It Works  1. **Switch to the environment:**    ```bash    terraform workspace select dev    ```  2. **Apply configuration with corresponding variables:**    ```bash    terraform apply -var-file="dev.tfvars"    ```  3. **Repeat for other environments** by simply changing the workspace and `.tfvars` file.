## What's Inside?

  * **Workspaces**: Each environment (e.g., `dev`, `staging`, `prod`) gets its own isolated **state file**. This separation is crucial for:

      * **Safe, Parallel Deployments**: You can deploy or tear down infrastructure in one environment without affecting others.
      * **Reduced Risk**: Changes in one workspace won't inadvertently impact resources managed by another.

  * **`terraform.tfvars` Files**: These files serve as dedicated configuration blueprints for each environment. You'll have:

      * `dev.tfvars`
      * `staging.tfvars`
      * `prod.tfvars`

    Each `tfvars` file contains **customized input variable values** specific to its environment. This includes things like CIDR blocks for network configurations, instance counts for virtual machines, and region settings, ensuring your infrastructure is perfectly tailored to the needs of each stage.

-----

## How It Works in Practice

The workflow is straightforward and highly efficient:

1.  **Select Your Environment**: First, switch to the desired Terraform workspace. This action tells Terraform which state file to use for your operations.

    ```bash
    terraform workspace select dev
    ```

    If the workspace doesn't exist yet, you can create it with `terraform workspace new dev`.

2.  **Apply Configuration with Environment Variables**: Once the workspace is active, apply your Terraform configuration, explicitly linking it to the corresponding `tfvars` file. This injects the environment-specific values into your infrastructure code.

    ```bash
    terraform apply -var-file="dev.tfvars"
    ```

3.  **Repeat for Other Environments**: To manage other environments, simply repeat steps 1 and 2, changing the workspace and `tfvars` file accordingly. This consistent process minimizes human error and streamlines your infrastructure deployments.

This approach empowers you to maintain distinct, yet consistently managed, infrastructure environments, making your deployment process predictable and reliable.
